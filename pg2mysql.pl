#!/usr/bin/perl

use warnings;
use strict;

use Getopt::Long;

my @skip_tables;
GetOptions ("skip=s" => \@skip_tables);

$| = 1;

print "-- Generated by pg2mysql\n";

print "set autocommit = off;\n";
print "set foreign_key_checks = off;\n";

# TODO: make configurable
print "drop database if exists public;\n";
print "create database public;\n";

my $in_create = 0;
my $in_alter = 0;
my $in_insert = 0;
my $skip_table = 0;
my $debug = 0;
my @deferred_ai_statements;

# We need one line of lookahead for some of these transformations
my $line;
my $nextline;

while (<>) {
    $line = $nextline;
        
    chomp;
    $nextline = $_;
    next unless $line;

    handle_line($line, $nextline);
}

$line = $nextline;
$nextline = "";

handle_line($line, $nextline);

foreach my $deferred ( @deferred_ai_statements ) {
    print "$deferred\n";
}

sub handle_line {
    my $line = shift;
    my $nextline = shift;

    if ( $in_create || $line =~ m/^\s*CREATE TABLE/ ) {
        ($line, $in_create, $skip_table) = handle_create($line);
        debug_print("outside of create, in_create = $in_create\n");
    } elsif ( $in_alter || $line =~ m/^\s*ALTER TABLE/ ) {
        ($line, $in_alter, $skip_table) = handle_alter($line, $nextline);
        debug_print("outside of alter, in_alter = $in_alter\n");
    } elsif ( $in_insert || $line =~ m/^\s*INSERT INTO/ ) {
        ($line, $in_insert, $skip_table) = handle_insert($line);
    } elsif ( $line =~ m/^\s*CREATE INDEX/ ) {
        ($line, $skip_table) = handle_create_index($line);
    } else {
        print_warning("$line");
        return;
    }

    print "$line\n" if ( $line && !$skip_table );
}

sub handle_create {
    my $line = shift;

    if ( $line =~ m/^\s*CREATE TABLE (\S+)/ ) {
        if ( grep { $1 eq $_ } @skip_tables ) {
            print_warning("skipping table $1");
            $skip_table = 1;
        } else {
            $skip_table = 0;
        }
    }
    
    debug_print("input line is $line\n");

    # Some notes on these conversions:
    # 
    # Array types are not supported in mysql, but for arrays of
    # strings, we can fake it because the insert statement looks like
    # '{value1,value2}'
    #
    # Some types can't be supported so are just left alone to fail in
    # mysql, including: tsvector
    
    $line =~ s/"/`/g;
    $line =~ s/"/`/g;
    $line =~ s/ int_unsigned/ integer UNSIGNED/;
    $line =~ s/ smallint_unsigned/ smallint UNSIGNED/;
    $line =~ s/ bigint_unsigned/ bigint UNSIGNED/;
    $line =~ s/ serial / integer auto_increment /;
    $line =~ s/ uuid/ varchar(36)/;
    $line =~ s/ bytea/ BLOB/;
    $line =~ s/ boolean/ bool/;
    $line =~ s/ jsonb/ json/; # same as json in mysql
    $line =~ s/ bool DEFAULT true/ bool DEFAULT 1/;
    $line =~ s/ bool DEFAULT false/ bool DEFAULT 0/;
    $line =~ s/ `text\[\]`/ longtext/;
    $line =~ s/ text\[\]/ longtext/;
    $line =~ s/ `text`/ longtext/;
    $line =~ s/ text/ longtext/;
    $line =~ s/ character varying\(([0-9]*)\)\[\]/ longtext/;
    $line =~ s/ character varying\[\]/ longtext/;
    $line =~ s/ character \(([0-9]*)\)\[\]/ longtext/;
    $line =~ s/ character\[\]/ longtext/;
    $line =~ s/ character varying\(([0-9]*)\)/ varchar($1)/;
    $line =~ s/ character varying/ longtext/;
    $line =~ s/ character \(([0-9]*)\)/ char($1)/;
    $line =~ s/ character/ longtext/;
    $line =~ s/ DEFAULT \('([0-9]*)'::int[^ ,]*/ DEFAULT $1/;
    $line =~ s/ DEFAULT \('([0-9]*)'::smallint[^ ,]*/ DEFAULT $1/;
    $line =~ s/ DEFAULT \('([0-9]*)'::bigint[^ ,]*/ DEFAULT $1/;
    $line =~ s/ DEFAULT nextval\(.*\) / auto_increment/; # doesn't seem to be used in most dumps, only in ALTER TABLE
    $line =~ s/::.*,/,/; # strip type cast info
    $line =~ s/::[^,]*$/,/; # strip type cast info
    $line =~ s/ timestamp with time zone/ timestamp/;
    $line =~ s/ timestamp without time zone/ timestamp/;
    $line =~ s/ timestamp DEFAULT '(.*)(\+|\-).*'/ timestamp DEFAULT '%1'/; # strip timezone in defaults
    $line =~ s/ timestamp DEFAULT now()/ timestamp DEFAULT CURRENT_TIMESTAMP/;
    $line =~ s/ timestamp( NOT NULL)?(,|$)/ timestamp DEFAULT 0${1}${2}/;
    $line =~ s/ DEFAULT .*\(\)//; # strip function defaults
    $line =~ s/ longtext DEFAULT [^,]*/ longtext,/; # text types can't have defaults in mysql

    my $field_def = ( $line !~ m/^CREATE/ && $line !~ m/^\s*CONSTRAINT/ && $line !~ m/\s*PRIMARY KEY/ && $line !~ m/^\s*\);/ );
    
    # backtick quote any field name as necessary
    # TODO: backtick field names in constraints as well
    if ( $field_def && $line !~ m/^\s*`(.*?)` / ) {
        $line =~ m/^\s*(.*?) /;
        my $col = $1;
        $line =~ s/$col/`$col`/;
    }
            
    my $statement_continues = 1;
    if ( $line =~ m/\);$/ ) {
        $statement_continues = 0;
    }

    debug_print("in create, cont = $statement_continues\n");
    
    return ($line, $statement_continues, $skip_table);
}

sub handle_alter {
    my $line = shift;
    my $nextline = shift;

    $line =~ s/ALTER TABLE ONLY/ALTER TABLE/;
    $line =~ s/DEFERRABLE INITIALLY DEFERRED//;
    $line =~ s/USING btree.*;/;/;

    if ( $line =~ m/^\s*ALTER TABLE (\S+)/ ) {
        if ( grep { $1 eq $_ } @skip_tables ) {
            print_warning("skipping table $1");
            $skip_table = 1;
        } else {
            $skip_table = 0;
        }
    }

    # We can't put a foreign key constraint onto a table that we skipped
    if ( $nextline =~ m/\s*ADD CONSTRAINT .*? FOREIGN KEY .*? REFERENCES ([^\(]+)/ ) {
        if ( grep { $1 eq $_ } @skip_tables ) {
            print_warning("skipping foreign key on skipped table $1");
            $skip_table = 1;
        }
    }
    
    debug_print("alter line is $line\n");
    
    if ( $line =~ m/ADD CONSTRAINT (\S+) UNIQUE \(([^\)]*)\);/ ) {
        my @cols = split /\s*,\s*/, $2;
        my @quoted = map { "`$_`" } @cols;
        my $joined = join ",", @quoted;
        $line = "ADD CONSTRAINT $1 UNIQUE ($joined);";
    }
    
    my $statement_continues = 1;
    if ( $line =~ m/\);$/ ) {
        $statement_continues = 0;
    } elsif ( $line =~ m/FOREIGN KEY.*\)\s*;$/ ) { # foreign key alters add a space before the semicolon
        $statement_continues = 0;
    }

    # For tables with a sequence for an ID, pg_dump does the following:
    # 1) create the table with no keys
    # 2) create a sequence for that table
    # 3) alter table to set the default to that sequence nextval
    # 4) inserts
    # 5) alter table to add primary key
    #
    # This doesn't work in mysql. 2) and 3) are not supported at all,
    # and a column can't be set to auto_increment unless it's a key in
    # the table. So instead, when we see this pattern, we defer
    # auto_increment changes until after the primary key changes. This
    # also makes assumptions about the type of a primary key column
    # which may not be accurate.  
    #
    # ALTER TABLE public.account_emailaddress ALTER COLUMN id SET DEFAULT nextval

    if ( $line =~ m/\s*ALTER TABLE (\S+) ALTER COLUMN (\S+) SET DEFAULT nextval/i ) {
        unless ( grep { $1 eq $_ } @skip_tables ) {
            push @deferred_ai_statements, "ALTER TABLE $1 MODIFY `$2` integer auto_increment;";
            $line = "";
        }
    }
    
    return ($line, $statement_continues, $skip_table);
}

sub handle_insert {
    my $line = shift;

    if ( $line =~ m/^\s*INSERT INTO (\S+)/ ) {
        if ( grep { $1 eq $_ } @skip_tables ) {
            print_warning("skipping table $1");
            $skip_table = 1;
        } else {
            $skip_table = 0;
        }
    }
    
    # 2020-06-08 11:27:31.597687-07
    $line =~ s/'(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}.\d{6})(-|\+)\d{2}'/'$1'/g; # timestamp literal strings need timezones stripped
    $line =~ s/\\([nt])/\\\\$1/g; # tab and newline literals, need an additional escape (for JSON strings)
    $line =~ s/\\"/\\\\"/g; # escaped double quote characters

    my $statement_continues = 1;
    if ( $line =~ m/\);$/ ) {
        $statement_continues = 0;
    }
    
    return ($line, $statement_continues, $skip_table);
}

sub handle_create_index {
    my $line = shift;

    # CREATE INDEX account_emailaddress_email_03be32b2_like ON public.account_emailaddress USING btree (email varchar_pattern_ops);
    $line =~ s/ USING btree//;
    $line =~ s/ varchar_pattern_ops//;
    
    $line =~ m/CREATE INDEX (\S+) ON (\S+)\s*\(([^\(]+)\)/;
    if ( $2 ) {
        if ( grep { $2 eq $_ } @skip_tables ) {
            return ($line, 1);
        }
    }

    # TODO: backtick column names in index
    return ($line, 0);
}

sub ids {
    my $s = shift;
    $s =~ s/"/`/g;
    return $s;
}

sub debug_print {
    my $msg = shift;
    print $msg if $debug;
}   

sub print_warning {
    my $msg = shift;
    # TODO: putting these in the SQL file causes problems for the dolt batch parser (doesn't understand comments)
    warn "-- $msg\n";
}
